---
tags: [Linux, SHELL]
---

![terminal and command line]({{site.ina}}/terminal-and-command-line.png)

### Show things in a directory

A modern Linux PC looks and feels similar to a Windows PC or a Mac. You can use
your mouse to click around, open files, launch programs. What we are going to
cover here is how to use commands instead of a mouse to control your PC. The
first command you may type into a Linux command line is probably `ls`. But
where can you find a Linux command line? In a modern operating system, a
command line is normally provided in a program generally called **terminal** as
shown in the screenshot above. A command is simply a text string you type into
this program. ([MobaXterm][] is such a program for Windows.) You need to press
<kbd>Enter</kbd> to execute a command. The output of the executed command is
shown in the terminal and a new command line is provided below the output
waiting for new input.

[MobaXterm]: {% post_url learning/2020-01-12-easiest-way-to-experience-linux-in-windows %}

The `ls` command lists files and folders in the current directory. This is
equivalent to opening the file explorer in Windows. In the latter, you can tell
whether an item is a file or a directory by its icon. After executing `ls` in a
Linux terminal, the file and folder names will be printed under the command
line. There is no icon for you to tell which is a file or a folder. You can
turn on an option of the `ls` command so that it attaches a letter after the
name of an item to indicate the type of the item:

```sh
$ ls -F
file  folder/  executable*  shortcut@
```

The `-F` string after `ls` is used to turn on this option. I'd like to remember
`F` as **file type** so that I won't forget about it. A dash is needed
IMMEDIATELY before a one-letter option. No space is allowed in between the dash
and the option. A space IS needed between the command and an option though,
otherwise, they'll be regarded by Linux as a single command `ls-F` (which does
not exist) instead of a command `ls` with an option `-F`. A final remark before
we move on is that CASE MATTERS in Linux. You cannot replace `F` with `f` or
`ls` with `Ls`. Actually, there is no `f` option for the `ls` command, and `Ls`
is not a Linux command.

I put a `$` symbol in front of the `ls` command to represent the **command
prompt**, which are simply some text strings normally ended with `$`. They can
be informative or funny. You can change it to your likings once you know more
about Linux. The prompt is not part of the command. You don't have to type it
in your terminal when you follow this instruction. But it is a common practice
to put `$` in front of a command in tutorials to distinguish a command from its
output printed below it.

Now let's take a look at the output of the `ls -F` command. A normal file has
nothing attached to its end. A folder has a slash `/` attached. Note that `\`
is called back slash and is different from `/`. An executable, or a program
that you can run, has a `*` attached to its end. This is necessary because most
Linux programs do not end with `.exe`, you need the `*` to tell whether an item
is an executable or a normal file. A shortcut to an item located somewhere else
ends with an `@`. It is the same as a **Desktop shortcut** in Windows.

A drawback of this method is that someone may regard an attached letter as part
of the name of an item. He may try to do something with `executable*` instead
of `executable` in the example above but only gets an error message saying that
there is no file called `executable*`.

A better way is to show files in different colors according to their types. For
example, normal file names can be shown in white, folders in blue, executables
in red, shortcuts in purple, etc. as shown in the screenshot above. To achieve
this, you need to turn on another option of `ls`, that is, `--color`:

```sh
$ ls --color
```

It is very common for a Linux command to use one dash `-` to indicate a
one-letter option and two dashes `--` to indicate a long option, such as
`color` in this example. What if you want to turn the color display off? I know
it sounds strange, but somebody does prefer black and white. It turns out that
long options sometimes can take an argument. For example,

```sh
$ ls --color=never
```

turns the output back to black and white, where `never` is an argument of the
`color` option.

Note that in a Mac, `--color` does not exist. You should use `ls -G` instead.

To learn more about the type of a file, you can use the `file` command:

```sh
$ file some.exe
some.exe: PE32+ executable (console) x86-64 (stripped to external PDB)
```

![long output of ls]({{site.ina}}/long-output-of-ls.png)

It is possible to check the type, the size, the modified date and time of a
file by choosing detailed view in the *Windows File Explorer* as shown in the
screenshot above. The same effect can be achieved by turning on the `-l` (long
list) option of `ls`:

```sh
$ ls -l
-rw-r--r--  1 jintonic physino 12005 Jan  3 16:35 README.md
drwx------+ 1 jintonic physino     0 Sep 26  2018 mail/
lrwxrwxrwx  1 jintonic physino    34 Oct 23  2017 Dropbox -> /cygdrive/c/Users/jintonic/Dropbox/
```

The meaning of each column is briefly explained in the screenshot above.
Detailed explanation of **file permission** can be found in
<https://www.guru99.com/file-permissions.html>

The file size is shown in the unit of byte, which can be a long number for a
large file. You can display it in human readable format using the `h` option,
which can share a single `-` with the `l` option:

```sh
$ ls -lh
-rw-r--r--  1 jintonic physino 1.2G Jan  3 16:35 some.dat
-rw-r--r--  1 jintonic physino 4.3K Jan  3 16:35 file.txt
```

There is an option in the *Windows File Explorer* to show hidden files in a
directory. Similar things can be done in Linux using the `a` (means *all*)
option of `ls`:

```sh
$ ls -a
.  ..  .bashrc  mail  README.md
```

The first three items start with a dot. In Linux, you can add a dot at the
beginning of a file name to turn it into a hidden file. In this example, `mail`
and `README.md` are normal files. `.bashrc` is an hidden file. The single and
double dots have very special meanings. To find out, we need to combine the `a`
and `F` option:

```sh
$ ls -aF
./  ../  .bashrc  mail/  README.md
```

From the `/` letter attached to the ends of them, we know that they are
directories. In fact, One dot means the current directory, two dots means the
parent directory. This brings us to the next section.

### Change directories

The command to change to a different directory is `cd`. To go to the `mail/`
directory, you type (don't forget <kbd>Enter</kbd>)

```sh
$ cd mail
```

Note that `mail` is an *argument* of the `cd` command. If you don't have a
`mail/` directory, this command will complain that it cannot open this
directory. To make sure that this works for you, run `ls` first to check what's
in your current folder. If there is a directory, replace `mail` with the name
of that directory.

To go back to the previous directory, you have two choices. First,

```sh
$ cd ..
```

where `..` means the parent directory as we learned from the previous section.
Second,

```sh
$ cd -
```

where `-` is not part of an option. Instead, it means to *go back to the
previous directory*. The way to remember this is to regard `-` as a minus sign
instead of a dash. Minus means you lose your current position and go back to
the previous one.

You can go into a sub-sub-directory using one command

```sh
$ cd mail/inbox
```

This directory chain can be as long as you want. In this case, `cd ..` brings
you back to the `mail` folder, while `cd -` brings you back to the folder that
contains `mail`.

Up to this point, it looks like that the `ls` command does not take any
argument, while the `cd` command has to take an argument, which is not true.
You can use

```sh
$ ls mail/inbox
```

to list mails in the `mail/inbox` directory. And `cd` without any argument will
take you back to your **home** directory. What is the **home** directory? This
is not a concept familiar to Windows users. Linux uses a quite different
method to organize its files. To learn more, please search "Linux directory
structure" in Google. In short, each Linux user gets a dedicated directory for
her to store her files, which is called the user's home directory. When the
user open a terminal, the start directory is her home directory. The name of
the home directory is the same as the user name. To illustrate how the user
home directories are organized in Linux, let's assume a Linux machine with two
users, jack and rose:

```sh
$ cd /home
$ ls -F
jack/   rose/
```

The home directories for both jack and rose are placed in the same directory
called `/home`. (Note in macOS, the home directories are placed in `/User`.)
You may ask why this time the `/` is placed in front of a directory instead of
after it? The leading `/` still represents a directory, but it is a very
special one. It is the top directory of the [Linux directory
tree](https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard), or the
*root* directory. It has no parent directory above it. That's why you cannot
put any string in front of it anymore. So

```sh
$ cd /
$ ls -F
bin/  boot/  etc/  home/
```

brings you to the root directory and show you what's in it, where you can find
the `home/` directory that contains all users' home directories.

A directory chain like `mail/inbox` is called a *path*. If a path starts with
`/`, it is called an **absolute path**, since you start at the root directory.
Otherwise, it is called a **relative path**, which starts at the current
directory. So `mail/inbox` is a relative path, it is in the current directory,
instead of in the root directory.

Suppose rose asks you to check a document in her home directory, you can do it
in two ways:

```sh
$ cd /home/rose
```

or

```sh
$ cd ~rose
```

The combination of the tilde symbol `~` and `rose` is a shortcut to `/home/rose`.

A single `~` without any username following it is a shortcut to your own home
directory. So

```sh
$ cd ~
```

is equivalent to

```sh
$ cd
```

A great way to use `~` can be something like this:

```sh
$ cd ~/mail/inbox
```

which brings you from rose's home directly back to your email inbox located in
your home directory. Note that this command cannot be typed as `cd
~mail/inbox`, since `~mail` means the home directory of a user named `mail` (if
there is any), while `~/mail` means the `mail/` directory in your own home
directory.

Suppose that you'd like to get into a directory called `folderWithALongName`.
In Windows, you just need to double click its icon in the *File Explorer*.
While in Linux, the operation involves a lot of typing, until you learn the
<kbd>Tab</kbd> trick, that is, the Linux command line can automatically
complete a file or directory name when you press <kbd>Tab</kbd> after you type
in the first a few letters. So `cd f`<kbd>Tab</kbd> will become `cd
folderWithALongName` automatically if there is no other file starts with `f`.
If there is another file in the same directory called `flights`, nothing
happens when you press <kbd>Tab</kbd> after `f`. Don't give up yet! If you
press <kbd>Tab</kbd> again, the command line will list all files starting with
`f` for you to chose. You can typing a few more letters to break the ambiguity,
for example `fol`, and then press <kbd>Tab</kbd> again to complete the whole
name. So please make it a habit to hit <kbd>Tab</kbd> frequently with your left
pinky when you use `cd`. It will save you a lot of typing.

Another advantage of using <kbd>Tab</kbd> to complete a file or a directory
name is to make sure that you don't type it wrong. For example, if you type `cd
folderw` and two <kbd>Tab</kbd>s after it, nothing will happen, since there is
no file starting with `folderw`. You should then check your spell and realize
that you should have typed `folderW` instead of `folderw`. Such a mistake is
very common in those who just switch from Windows to Linux and have not yet
gotten used to the CASE SENSITIVE nature of Linux. <kbd>Tab</kbd> is your
friend to help you avoid such mistakes.

A file name in Windows can contain *space* in it, for example, `My Document`.
This is not a good idea in Linux though, since

```sh
$ cd My Document
```

will give you an error message `cd: too many arguments`. This is because the
`space` in the command line is used to separate arguments. `My` and `Document`
are separated by the space and are regarded as two different directories in
this case. You cannot go to two different directories at the same time, which
results in the error message.

There are two ways to solve this problem in Linux. One is to quote the file
name:

```sh
$ cd "My Document"
```

The other is to **escape** the *space* with a back slash `\`:

```sh
$ cd My\ Document
```

The `\` in front of the *space* turns the *space* to a normal space from 
a separator between arguments of a command. In general, `\` can be used in
front of special letters in a file name to turn them to normal text characters.
For example, if a directory is named `a "Strange" directory\`, we can turn all
special characters back to normal one by one using `\`:

```sh
$ cd a\ \"Strange\"\ directory\\
```

Yes, a `\` in front of another `\` turns the second `\` to a normal character.

Remember, the <kbd>Tab</kbd> trick still works for names that contain special
characters. So `cd My`<kbd>Tab</kbd> may become `cd My\ Document`
automatically, which is nice.

Even though there is a solution for a file name with *space* in it, you should
try to avoid creating such a name in Linux. Alternatives include `MyDocument`,
`My_Document` or simply `doc`.

One more thing you may need to know before we move to the next section is the
`pwd` command. It is used to *print the working directory*, or where you are
right now, in case you get lost after many `cd` commands:

```sh
$ pwd
/home/jack/mail/trash
```

### Show file content

Equipped with `ls` and `cd`, you can already navigate through a Linux directory
tree. But when you encounter a file named `README.txt`, how can you see its
content? In Windows, it is very easy, you just need to double click the icon,
the file will then be shown in a `notepad`. In Linux, there are programs like
`notepad` as well, they are called [text editors]({% post_url
learning/2016-09-01-terminal-based-text-editors %}). However, what we really
need here is to simply view the file instead of editing it. The simplest way is
to use the `cat` command:

```sh
$ cat README.txt
```

which print the contents of `README.txt` in the terminal. I am always wondering
if there is a Linux command called `dog`. But no, there is none. The `cat`
command works nicely for short files that can be shown within the terminal
window. If a file is longer than what can be shown in a terminal, its contents
will be flashed quickly through the terminal window until the end of it. To
check the disappeared the contents, you can scroll your screen up using your
mouse wheel. If it does not work, try to hold <kbd>Shift</kbd> and then use
<kbd>PageUp</kbd> and <kbd>PageDown</kbd> to scroll up and down.

If you are only interested in part of the contents, for example, only a few
lines at the beginning or end of the file, you can use `head` and `tail`
commands:

```sh
$ head README.txt
$ tail README.txt
```

which shows the first/last 10 lines of `README.txt`, respectively. To specify
how many lines to be shown, you can use the `-n` option, which works for both
`head` and `tail`:

```sh
$ head -n 12 README.txt
$ tail -n 31 README.txt
```

In some system, `-n 12` can be shortened to `-12`.

The `cat`, `head` and `tail` commands are not real viewers. There are two text
viewers that you can use in Linux, `more` and `less`. `less` is better than
`more`, since sometimes *less is more* :)

```sh
$ less README.txt
```

replaces the whole terminal screen with the contents of `README.txt`. To go
back to your command line, you need to type `q` to quit `less`. Inside `less`,
you can use <kbd>PageUp</kbd> and <kbd>PageDown</kbd> to flip pages without
holding <kbd>Shift</kbd>. <kbd>Shift</kbd>+<kbd>PageUp</kbd> and
<kbd>PageDown</kbd> still work, but they flip the terminal pages, instead of
the `less` pages.

The formal name of a `less` page is *alternate screen*. It is NOT the original
terminal *screen* (or *window* as I call it previously). It disappears when you
quit `less` and you are back to the original terminal screen as if `less` has
not printed out anything to the screen. This is a common behavior of many
terminal based programs, such as text editors. You need to realize that the
*alternate screen* is NOT the terminal screen and that they expect completely
different ways of operation. For example, the `less` *alternate screen* does
not understand the `ls` and `cd` commands. To see what `less` does understand,
press <kbd>h</kbd> within `less` to check its help page.

`less` is completely keyboard driven, that is, you use your keyboard instead of
your mouse to control it. The <kbd>j</kbd> key scrolls the page down by one
line, the <kbd>k</kbd> key scrolls the page up by one line. The <kbd>/</kbd>
key allows you to start a search of a string in `README.txt`. The <kbd>n</kbd>
key is used to go to the next occurrence of the search string, <kbd>N</kbd>
goes to the previous occurrence. It takes some practice for you to get used to
these key strokes. But it is worth the effort since many Linux programs share
the same hot keys.

Go back to ancient history, a keyboard at that time did not even have arrow
keys. No wonder ancient programs like `less` can be entirely controlled by keys
on the main typing keypad, which can sometimes more efficient than the
mouse-driven approach.

Now that we learned how to control `less`, I can introduce a very important
Linux command, `man`. It is used to show manuals of other Linux commands in
`less`. For example,

```sh
$ man ls
```

displays a long description of all options that go with the `ls` command. To
learn more about `man`, you can

```sh
$ man man
```

To know more about color related option of `ls`, you can press <kbd>/</kbd> and
type `color` and <kbd>Enter</kbd> to search for the string `color` in the man
page.

You can search for a string in a text file without even opening it in `less`.
For example, you can print lines in `README.txt` that contains "some string" on
your terminal screen using:

```sh
grep "some string" README.txt
```

### Combination of commands

The output of a command in the terminal screen has a formal name, `stdout`, or
*standard output stream*. Guess what, a Linux command also has a `stdin` to
accept output stream from another command. Two Linux commands can be chained
with a pipe `|` in between. For example, I can connect the `stdout` of `ls` to
the `stdin` of `less` using `|`:

```sh
$ ls | less
```

This is useful when the output of `ls` is more than that can be displayed in
one terminal screen. You can navigate through the long output of `ls` within
the `less` *alternate screen* using all the `less` hotkeys.

Now guess what the following command chain does:

```sh
$ cat README.txt | head -20 | tail -1
```

It shows the 20-th line of `README.txt` on the terminal screen.

```sh
$ ls -l | grep exe
```
only prints lines that contains "exe" in the `ls -l` outupt.

It is also possible to save the output of a command into a file for detailed
check sometime later using

```sh
$ ls > output.txt
```

You can then use `less output.txt` to check the output at any time you want. If
there is already a file named `output.txt` in the current directory, its old
contents will be replaced by the output of `ls`. The following command can be
used to append the output of `ls` to the end of the existing contents:

```sh
$ ls >> output.txt
```

Now you may start to sense the infinite possibility provided by the combination
of simple commands using the `stdout` and `stdin` mechanism. Please check
<https://www.howtogeek.com/435903/what-are-stdin-stdout-and-stderr-on-linux/>
and <https://www.commandlinefu.com/commands/browse/sort-by-votes> to learn
more.

If the output of a command is redirected to a file, it won't show up on the
terminal screen (stdout) anymore. To achieve both, you need a `tee` to split
the data flow:

```sh
$ ls | tee output.txt
```

This way, the `ls` output appears both on the screen and in `output.txt`.


### Create or delete things

Before you change anything, you need to understand that you can only change
things in your home directory, which makes sense. If everybody can delete
system files in a Linux machine, the machine will become unusable fast. If you
get an error message saying "Permission denied", run `pwd` to check where you
are. If you are not in your home directory, type `cd` to go back to your home
directory.

The following command creates a directory chain:

```sh
$ mkdir -p example/advanced/A1
```

The option `-p` tells `mkdir` to make parent directories as needed. If
`example/` does not exist before running the command, `mkdir` will just create
it. If `-p` is ignored and `example/` does not exist, `mkdir` will give the
following error message:

```sh
cannot create directory 'example/advanced/A1': No such file or directory
```

The following command deletes (removes) a file:

```sh
$ rm randomFile
```

To delete a directory, you should first delete everything in it and then delete
itself. Or you can use a `-r` flag to tell `rm` to remove everything inside
together with the directory:

```sh
$ rm -r aDirectoryContaintsSomethingInIt/
```

If you use the `-i` option, `rm` will ask for confirmation before doing
something:

```sh
$ rm -i randomFile
rm: remove regular file 'randomFile'?
```

press `y` to continue, `n` to quit. If you are tired pressing `y` for a long
list of files to be deleted, you can use the `-f` flag to force deleting
everything without confirmation:

```sh
$ rm -rf dir
```

It is frequently used together with `-r` to avoid typing `y` for every file in
`dir`.

The following command moves a folder to another place. In this case, order
matters. You are moving the first item, not the second one.

```sh
$ mv example/advanced/A1 example/A2
```

If there is already a folder called `A2`, the command moves `A1` inside `A2`.
The final result is that you have `example/A2/A1`. If there is no folder called
`A2`, the command moves `A1` from `example/advanced/` to `example` and renames
it to `A2`. This tells us that `mv` can do two things: one is to move things,
the other is to rename a thing.

You can move many things at the same time. The following command moves
`thing1`, `thing2`, and `thing3` to the `destination/` directory. The order of
`thing1`, `thing2` and `thing3` does not matter, but `destination/` must be the
last argument.

```sh
$ mv thing1 thing2 thing3 destination
```

An easier way to achieve the same thing is to use a [wildcard character](https://en.wikipedia.org/wiki/Wildcard_character) `*` to represent
any character in the command:

```sh
$ mv thing* destination
```

`thing*` matches `thing1`, `thing2`, `thing3`, and `thingWhatEver` if it exists.

You can also create shortcuts to your favorite folders or files using the `ln`
(link) command. In Linux, a shortcut is called a link. The following command
will create a link called `simpleExample` to the `example/advanced/A1` folder
in the current folder.

```sh
$ ln -sf example/advanced/A1 simpleExample
```

Please use `man ln` to check the meaning of the `-sf` flags.

### Edit text files

We've learned how to view a text file using `cat`, `less`, etc. You need
another type of programs to modify a text file. They are called [text
editors]({% post_url learning/2016-09-01-terminal-based-text-editors %}). If
you have a file called `output.txt` in your current directory, try one of the
following commands based on your operating system:

```sh
$ edit output.txt # in MobaXterm local terminal in Windows
$ open output.txt # in macOS terminal
$ gedit output.txt # in Ubuntu terminal
```

Texts after `#` (including `#` itself) are called comments, they are simply
explanations of the command.  You don't have to type them into your terminal.
Even if you do, you system will ignore everything from `#` to the end of the
command line.

If there is no `output.txt` before you run these commands, the editors will
create it. The exception is 

```sh
$ edit output.txt # in MobaXterm local terminal in Windows
```
It looks like that you cannot create a file in MobaXterm this way. You need to
first create an empty file using the `touch` command:

```sh
$ touch output.txt # create the file
$ edit output.txt # open it in the MobaXterm text editor
```

### Job control
When you run `gedit otuput.txt` in a real Linux terminal (not in MobaXterm or
macOS terminal), your terminal will wait till you quit your editor to give you
another command line. If you want to have your command line back without
quitting your editor, you need to go back to your terminal window, hold
<kbd>Ctrl</kbd> and press <kbd>z</kbd> to *suspend* your editor. The
*suspended* editor cannot be used anymore unless you use the `bg` command to
send it to the background running job list of your terminal:

```sh
$ gedit output.txt # use <ctrl>-z to suspend gedit
$ bg # send gedit to the background job list of your terminal
```

After that, both your terminal and editor can be used. You can achieve this effect in one command:

```sh
$ gedit output.txt &
```

The `&` symbol directly run `gedit` as a background job.

You can use

```sh
$ jobs
```
to list all background jobs in your current terminal, and the following command
to bring them back to foreground:

```
$ fg
```

`man bash` and search for "job control" to learn more about this topic.


### Shell

You may use `ls --color -hal` very often. To save typing, you can create a short alias of this long command:

```sh
$ alias l='ls --color -hal'
```

Now you can simply type `l` as a command that achieves the same effect as the long version. `alias` without any argument lists all alias that already exist. Try it out in your terminal and you will be amazed how creative people are in creating short commands.

Unfortunately, your terminal cannot remember this setup. When you open a new terminal, all your settings are gone. In Linux, user preferences of a program are normally saved in a text file called configuration file. A user specific configuration file is normally saved in your home directory. A configuration file for everyone in a Linux machine is saved in `/etc`. A configuration file is normally hidden, which means that its name starts with a dot `.`. It is normally ended with `rc`. So a typical configuration file name would look like `.prgrc`, and it is likely to be in your home directory.

But which program is responsible for dealing with the command line? Your first guess might be the terminal. But it's not. The terminal handles the user interface, it passes user input to a program called `shell`, which processes all the commands.

It is a bit confusing when we think about the roles that a *termnial* and a 
*shell* play. Simply put, a *terminal* provides a frame, where a *shell* 
exists. The size of the terminal, the font used to display the *shell* prompt, 
commands and output, as well as the mouse clicks are handled by the *terminal*. 
Key strokes will be processed first by the *terminal* and then sent to the 
*shell*.

The middle click of a mouse in most of the Linux terminals would actually do 
the job of *paste*, the same as the <kbd>Ctrl+v</kbd> combination in *Windows*. 
Copy can be done by simply selecting some text in the terminal while holding 
the left button. Double left click on a word will select and copy the whole 
word. Triple click will select the whole line where the mouse is pointing to. 
Right click will most probably bring up a menu provided by the *terminal*.

According to [wikipedia][],
> a shell is a user interface for access to an operating system's services. In 
> general, operating system shells use either a command-line interface (CLI) 
> or graphical user interface (GUI), depending on a computer's role and 
> particular operation. It is named a shell because it is a layer around the 
> operating system kernel.

Practically, the word *shell* almost always refers to *CLI* (command Line Interface) instead of *GUI* (Graphic User Interface). In some sense, to learn Linux command-line is to learn how to use a *shell*.

There are many [shells](http://www.ibm.com/developerworks/library/l-linux-shells/) out there. If you don't have any preference at this moment, please try to learn [Bourne Again SHell][bash], or [bash][] in short, first because it is probably the most commonly available and used one.

The configuration file for [bash][] is `.bashrc` in your home directory. Check if you have one:

```sh
$ cd # go to your home directory
$ ls -a # list all files including hidden ones
```

If not, run `touch .bashrc` to create it and then use a text editor to open it, go to the end of it and add

```sh
alias l='ls --color -hal' # for macOS replace --color with -G
```

save and quit. Now open another terminal and check if you can use `l` in it.

What else can we save in `~/.bashrc` instead of aliases? One interesting thing you can do is to setup the so-called [environmental variables](https://en.wikipedia.org/wiki/Environment_variable). They control the environment within with your commands run. Run the following command to list all environmental variables that currently take effect in your shell:

```sh
env
```

Normally, the list is overwhelmingly long. Let's start with a few important ones first. First of all, I'd like to mention `PS1`. It controls what can be shown as the command prompt. A command prompt sometimes looks like this:


``` shell
UserName@HostName:~ >
```

or this:

``` shell
root@HostName:/ $
```

or something really fancy: 

``` shell
UserName@HostName:~ | 8:30 am | battery: 34% | :-)
```

Check your current setting using

```sh
env | grep PS1
```

If you are not satisfied with it, put the following line to your `.bashrc`

```sh
export PS1='\u@\h:\w\$ '
```

save and quit, open a new terminal to see the difference. If you want to use the new setup in your current shell, run

```sh
source ~/.bashrc
```

The effect of some of the environmental variables is not as obvious as that of `PS1`. To check if your setup is successful, you can use the `echo` command to print out the content of an environment variable (case sensitive), for example,

``` shell
$ echo $SHELL # The SHELL variable saves the type of shell you are using.
$ echo $HOME # the location of your home directory
$ echo $PATH # list of directories where executables are located
```

You can use the `export` command to declare or change an environment variable directly in your shell and make it take effect immediately:

``` shell
$ export AMadeUpEnvVariable="some random text"
$ echo $AMadeUpEnvVariable
$ export SHELL=/bin/zsh # switch to another shell
$ export SHELL=/bin/bash # switch back to use bash
$ export PATH=~/bin:$PATH # add /home/YouUserName/bin/ to $PATH
$ export PS1='\u@\h:\w $' # set prompt to be UserName@HostName:PWD $
```

If you are satisfied with the result, save them in `.bashrc` so that you don't have to type them again next time you log in.


### PATH

### Hot keys

The *shell* provides a set of key combinations, or [shortcuts][], to facilitate the editing of the command line. For example, <kbd>Up</kbd> bring back the previous command, <kbd>Ctrl+a</kbd> moves your cursor to the beginning of the command line, <kbd>Ctrl+e</kbd> moves it to the end. Search for *bash shortcuts* on *Google* for a complete list.

[bash]:https://www.gnu.org/software/bash
[wikipedia]:https://en.wikipedia.org/wiki/Shell_(computing)
[shortcuts]:http://ss64.com/bash/syntax-keyboard.html
[env]:https://en.wikipedia.org/wiki/Environment_variable

### Check system information

```sh
$ # things after # is a comment, it won't be executed
$ /sbin/ifconfig # print IP address of the machine you are in
$ uname -a # print operating system information
$ cat /proc/cpuinfo # find out how many CPUs are there in this machine
$ cat /proc/meminfo # find out how big the memory is
$ top # find out who's using the resource, type q to quit
$ df -h # check the disk usage
```

``` shell
$ /sbin/ifconfig | grep inet | head -1 | awk '{print $2}'
```

This is a combination of many commands used to print out the IP address of the 
machine nicely. The *shell* needs to understand which words are commands, how 
to execute them one by one and how to pass output of one as input to another.
