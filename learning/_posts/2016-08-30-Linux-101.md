---
tags: [Linux, SHELL]
---

![terminal and command line]({{site.ina}}/terminal-and-command-line.png)

### Show things in a directory

A modern Linux PC looks and feels similar to a Windows PC or a Mac. You can use
your mouse to click around, launch programs. What we are going to cover here is
how to use commands instead of a mouse to control your PC. The first command
you may type into a Linux command line is probably `ls`. But where can you find
a Linux command line? In a modern operating system, a command line is normally
provided in a program generally called **terminal** as shown in the screenshot
above. A command is simply a text string you type into this program.
([MobaXterm][] is such a program for Windows.) You need to press <kbd>Enter</kbd>
to execute a command. The output of the executed command is shown in the
terminal and a new command line is provided below the output waiting for new
input.

[MobaXterm]: {% post_url learning/2020-01-12-easiest-way-to-experience-linux-in-windows %}

The `ls` command lists files and folders in the current directory. This is
equivalent to opening the file explorer in Windows. In the latter, you can tell
whether an item is a file or a directory by its icon. After executing `ls` in a
Linux terminal, the file and folder names will be printed under the command
line. There is no icon for you to tell which is a file or a folder. You can
turn on an option of the `ls` command so that it attaches a letter after the
name of an item to indicate the type of the item:

```sh
ls -F
file  folder/  executable*  shortcut@
```

The `-F` string after `ls` is used to turn on this option. I'd like to remember 
`F` as **file type** so that I won't forget about it. A dash is needed
IMMEDIATELY before a one-letter option. No space is allowed in between the dash
and the option. A space IS needed between the command and an option though,
otherwise, they'll be regarded by Linux as a single command `ls-F` (which does
not exist) instead of a command `ls` with an option `-F`. A final remark before
we move on is that CASE MATTERS in Linux. You cannot replace `F` with `f` or
`ls` with `Ls`. Actually, there is no `f` option for the `ls` command, and `Ls`
is not a Linux command.

Now let's take a look at the output of the `ls -F` command. A normal file has
nothing attached to its end. A folder has a slash `/` attached. Note that `\`
is called back slash and is different from `/`. An executable, or a program
that you can run, has a `*` attached to its end. This is necessary because most
Linux programs do not end with `.exe`, you need the `*` to tell whether an item
is an executable or a normal file. A shortcut to an item located some where
else ends with an `@`. It is the same as the **Desktop shortcut** in Windows.

A drawback of this method is that someone may regard an attached letter as part
of the name of an item. He may try to do something with `executable*` instead
of `executable` in the example above but only gets an error message saying that
there is no file called `executable*`.

A better way is to show files in different colors according to their types. For
example, normal file names can be shown in white, folders in blue, executables
in red, etc. To achieve this, you need to turn on another option of `ls`, that
is, `--color`:

```sh
ls --color
```

It is very common for a Linux command to use one dash `-` to indicate a
one-letter option and two dashes `--` to indicate a long option, such as
`color` in this example. What if you want to turn the color display off? I know
it sounds strange, but somebody does prefer black and white. It turns out that
long options sometimes can take an argument. For example,

```sh
ls --color=never
```

turns the output back to black and white, where `never` is an argument of the
`color` option.

![long output of ls]({{site.ina}}/long-output-of-ls.png)

It is possible to check the type, the size, the modified date and time of a
file by choosing detailed view in the *Windows File Explorer* as shown in the
screenshot above. The same effect can be achieved by turning on the `-l` (long
list) option of `ls`:

```sh
ls -l
-rw-r--r--  1 jintonic physino 105 Jan  3 16:35 README.md
drwx------+ 1 jintonic physino   0 Sep 26  2018 mail/
lrwxrwxrwx  1 jintonic physino  34 Oct 23  2017 Dropbox -> /cygdrive/c/Users/jintonic/Dropbox/
```

The meaning of each column is briefly explained in the screenshot above.
Detailed explanation of **file permission** can be found in
<https://www.guru99.com/file-permissions.html>

There is an option in the *Windows File Explorer* to show hidden files in a
directory. Similar things can be done in Linux using the `-a` (means *all*)
option of `ls`:

```sh
ls -a
.  ..  .bashrc  mail  README.md
```

The first three items start with a dot. In Linux, you can add a dot at the
beginning of a file name to turn it into a hidden file. In this example, `mail`
and `README.md` are normal files. `.bashrc` is an hidden file. The single and
double dots have very special meanings. To find out, we need to combine the `a`
and `F` option:

```sh
ls -aF
./  ../  .bashrc  mail/  README.md
```

From the `/` letter attached to the ends of them, we know that they are
directories. In fact, One dot means the current directory, two dots means the
parent directory. This brings us to the next section.

### Go to different directories

The command to change to a different directory is `cd`. To go to the `mail/`
directory, you type (don't forget <kbd>Enter</kbd>)

```sh
cd mail
```

To go back to the previous directory, you have two choices. First,

```sh
cd ..
```

where `..` means the parent directory as we learned from the previous section.
Second,

```sh
cd -
```

where `-` is not part of an option. Instead, it means *go back to the previous
directory*. The way to remember this is to regard `-` as a minus sign instead
of a dash. Minus means you lose your current position and go back to the
previous one.

You can go into a sub-sub-directory using one command

```sh
cd mail/inbox
```

This directory chain can be as long as you want. In this case, `cd ..` brings
you back to the `mail` folder, while `cd -` brings you back to the folder that
contains `mail`.

Up to this point, it looks like that the `ls` command does not take any
argument, while the `cd` command has to take an argument, which is not true.
You can use

```sh
ls mail/inbox
```

to list mails in the `mail/inbox` directory. And `cd` without any argument will
take you back to your **home** directory. What is the **home** directory? This
is not a familiar concept for Windows users. Linux uses a quite different
method to organize its files. To learn more, please search "Linux directory
structure" in Google. In short, each Linux user gets a dedicated directory for
her to store her files, which is called the user's home directory. When the
user open a terminal, the start directory is her home directory. The name of
the home directory is the same as the user name. To illustrate how the user
home directories are organized in Linux, let's assume a Linux machine with two
users, jack and rose:

```sh
cd /home
ls -F
jack/   rose/
```

The home directories for both jack and rose are placed in the same directory
called `/home`. You may ask why this time the `/` is placed in front of a
directory instead of after it? The leading `/` still represents a directory,
but it is a very special one. It is the top directory of the [Linux directory
tree](https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard), or the
*root* directory. It has no parent directory above it. So

```sh
cd /
ls -F
bin/  boot/  etc/  home/
```

brings you to the root directory and show you what's in it, where you can find
the `home/` directory that contains all users' home directories.

A directory chain like `mail/inbox` is called a *path*. If a path starts with
`/`, it is called an **absolute path**, since you start at the root directory.
Otherwise, it is called a **relative path**, which starts at the current
directory. So `mail/inbox` is a relative path, it is in the current directory,
instead of in the root directory.

Suppose rose asks you to check a document in her home directory, you can do it
in two ways:

```sh
cd /home/rose
```

or

```sh
cd ~rose
```

The combination of the tilde symbol `~` and `rose` is a shortcut to `/home/rose`.

A single `~` without any username following it is a shortcut to your own home
directory. So

```sh
cd ~
```

is equivalent to

```sh
cd
```

A great way to use `~` can be something like this:

```sh
cd ~/mail/inbox
```

which brings you from rose's home directly back to your email inbox located in
your home directory.

Suppose that you'd like to get into a directory called `folderWithALongName`.
In Windows, you just need to double click its icon in the *File Explorer*.
While in Linux, the operation involves a lot of typing, until you learn the
<kbd>Tab</kbd> trick, that is, the Linux command line can automatically
complete the directory name when you press <kbd>Tab</kbd> after you type in the
first a few letters. So `cd f`<kbd>Tab</kbd> will become `cd
folderWithALongName` automatically if there is no other file starts with `f`.
If there is another file in the same directory called `flights`, nothing
happens when you press <kbd>Tab</kbd> after `f`. Don't give up yet! If you
press <kbd>Tab</kbd> again, the command line will list all files starting with
`f` for you to chose. You can typing a few more letters to break the ambiguity,
for example `fol`, and then press <kbd>Tab</kbd> again to complete the whole
file name. So please make it a habit to hit <kbd>Tab</kbd> frequently with your
left pinky when you use `cd`. It will save you a lot of typing.

Another advantage of using <kbd>Tab</kbd> to complete a file name is to make
sure that you don't type it wrong. For example, if you type `cd folderw` and
two <kbd>Tab</kbd>s after it, nothing will happen, since there is no file
starting with `folderw`. You should then check your spell and realize that you
should have typed `folderW` instead of `folderw`. Such a mistake is very common
in people who just switch from Windows to Linux and have not yet gotten used to
the CASE SENSITIVE nature of Linux. <kbd>Tab</kbd> is your friend to help you
avoid such mistakes.

A file name in Windows can contain *space* in it, for example, `My Document`.
This is not a good idea in Linux though, since

```sh
cd My Document
```

will give you an error message `cd: too many arguments`. This is because the
`space` in the command line is used to separate arguments. `My` and `Document`
are regarded as two different directories in this case. You cannot go to two
different directories at the same time, which results in the error message.

There are two ways to solve this problem in Linux. One is to quote the file
name:

```sh
cd "My Document"
```

The other is to **escape** the *space* with a back slash `\`:

```sh
cd My\ Document
```

The `\` in front of the *space* turns the *space* to a normal space from 
a separator between arguments of a command.

Remember, <kbd>Tab</kbd> still works in this case. So `cd My`<kbd>Tab</kbd> may
become `cd My\ Document` automatically, which is nice.

Even though there is a solution for a file name with *space* in it, you should
try to avoid creating such a name in Linux. Alternatives include `MyDocument`,
`My_Document` or simply `doc`.

One more thing you may need to know before we move to the next section is the `pwd` command. It is used to *print the working directory*, or the current directory, in case you get lost after many `cd` commands:

```sh
pwd
/home/jack/mail/trash
```

### Show file content

Equipped with `ls` and `cd`, you can already navigate through a Linux directory
tree. But when you encounter a file named `README.txt`, how can you see its
content? In Windows, it is very easy, you just need to double click the icon,
the file will then be shown in a `notepad`. In Linux, there are programs like
`notepad` as well, they are called [text editors]({% post_url
learning/2016-09-01-terminal-based-text-editors %}). However, what we really
need here is simply to view the file instead of editing it. The simplest way is
to use the `cat` command:

```sh
cat README.txt
```

which print the contents of `README.txt` in the terminal. I am always wondering
if there is a Linux command called `dog`. But no, there is none. The `cat`
command works nicely for short files that can be shown within the terminal
window. If a file is longer than what can be shown in a terminal, its contents
will be flashed quickly through the terminal window until the end of it. To
check the disappeared the contents, you can scroll your screen up using your
mouse wheel. If it does not work, try hold <kbd>Shift</kbd> and then use
<kbd>PageUp</kbd> and <kbd>PageDown</kbd> to scroll up and down.

If you are only interested in part of the contents, for example, only a few
lines at the beginning or end of the file, you can use `head` and `tail`
commands:

```sh
head README.txt
tail README.txt
```

which shows the first/last 10 lines of `README.txt`, respectively. To specify
how many lines to be shown, you can use the `-n` option, which works for both
`head` and `tail`:

```sh
head -n 12 README.txt
tail -n 31 README.txt
```

In some system, `-n 12` can be shortened to `-12`.

The `cat`, `head` and `tail` commands are not real viewers. There are two text
viewers that you can use in Linux, `more` and `less`. `less` is better than
`more`, since sometimes *less is more* :)

```sh
less README.txt
```

replaces the whole terminal screen with the contents of `README.txt`. To go
back to your command line, you need to type `q` to quit `less`. Inside `less`,
you can use <kbd>PageUp</kbd> and <kbd>PageDown</kbd> to flip pages without
holding <kbd>Shift</kbd>. <kbd>Shift</kbd>+<kbd>PageUp</kbd> and
<kbd>PageDown</kbd> still work, but they flip the terminal pages, instead of
the `less` pages.

The formal name of a `less` page is *alternate screen*. It is NOT the original
terminal *screen* (or *window* as I call it previously). It disappears when you
quit `less` and you are back to the original terminal screen as if `less` has
not printed out anything to the screen. This is a common behavior of many
terminal based programs, such as text editors. You need to realize that the
*alternate screen* is NOT the terminal screen and that they expect completely
different ways of operation. For example, the `less` *alternate screen* does
not understand the `ls` and `cd` commands. To see what `less` does understand,
press <kbd>h</kbd> within `less` to check its help page.

`less` is completely keyboard driven, that is, you use your keyboard instead of
your mouse to control it. The <kbd>j</kbd> key scrolls the page down by one
line, the <kbd>k</kbd> key scrolls the page up by one line. The <kbd>/</kbd>
key allows you to start a search of a string in `README.txt`. The <kbd>n</kbd>
key is used to go to the next occurrence of the search string, <kbd>N</kbd>
goes to the previous occurrence. It takes some practice for you to get used to
these key strokes. But it is worth the effort since many Linux programs share
the same hot keys.

Go back to ancient history, a keyboard at that time did not even have arrow
keys. No wonder ancient programs like `less` can be entirely controlled by keys
on the main typing keypad, which can sometimes more efficient than the
mouse-driven approach.

### Combination of commands

The output of a command in the terminal screen has a formal name, `stdout`, or
*standard output stream*. Guess what, a Linux command also has a `stdin` to
accept output stream from another command. This can be achieve using a pipe
`|`. For example, I can connect the `stdout` of `ls` to the `stdin` of `less`
using `|`:

```sh
ls | less
```

This is useful when the output of `ls` is more than that can be displayed in
one terminal screen. You can navigate through the long output of `ls` within
the `less` *alternate screen* using all the `less` hotkeys.

Now guess what the following command chain does:

```sh
cat README.txt | head -20 | tail -1
```

It shows the 20-th line of `README.txt` on the terminal screen.

It is also possible to save the output of a command into a file for detailed
check sometime later. This is achieved using

```sh
ls > output.txt
```

You can then use `less output.txt` to check the output at time you want. If there is already a file named `output.txt` in the current directory, its old contents will be replaced by the output of `ls`. The following command can be used to append the output of `ls` to the end of the existing contents:

```sh
ls >> output.txt
```

Now you may start to sense the infinite possibility provided by the combination of simple commands using the `stdout` and `stdin` mechanism. Please check <https://www.howtogeek.com/435903/what-are-stdin-stdout-and-stderr-on-linux/> and <https://www.commandlinefu.com/commands/browse/sort-by-votes> to learn more.

### Misc

``` shell
$ # things after # is a comment, it won't be executed
$ # $ sign is the command prompt, it is not part of the command
$ /sbin/ifconfig # print IP address of the machine you are in
$ uname -a # print operating system information
$ cat /proc/cpuinfo # find out how many CPUs are there in this machine
$ cat /proc/meminfo # find out how big the memory is
$ top # find out who's using the resource, type q to quit
$ df -h # check the disk usage
$ pwd # (print working diretory) find out where you are
$ ls # list contents in the current directory
$ ls -l # detailed list of the contents in the current directory
$ ls -a # list contents in the current directory including hidden files
```

After [logging into a Linux machine using PuTTY from a Windows PC]({% post_url 
learning/2016-08-29-connect-to-Linux-from-any-Windows-PC %}), you may want to 
make sure that you are indeed in the machine that you intend to log in. Just 
as you get to a new place in the real world, you'd like to look around. You 
need the above commands to figure out the surroundings.

You may ask immediately "how am I suppose to remember the usage of so many 
commands?" The answer is "No, you don't need to remember, you *man* it":

``` shell
$ man ls
```

The command *man* shows the usage of a command in detail. Type <kbd>q</kbd> to 
quit when you are done.

You may also ask "What is this */* thingy there?". This is the sign to 
separate directories and files. The output of the command `pwd` may look like 
`/home/YouUserName`. That means you are in your home folder and your home 
folder is a subdirectory of the `/home` folder, which is in turn a 
subdirectory of the `/` folder, which is called the root directory.

You can go to a directory using the `cd` (change directory) command:

``` shell
$ cd / # go to the root directory
$ ls
$ cd # cd without any argument bring you back to your home directory
$ cd - # go back to previous directory
$ cd ~YouUserName # bring you to /home/YouUserName/
```

Now you can get around. How about create something here?

``` shell
$ mkdir bin doc # make two directories named bin and doc
$ ls # make sure you have created them
$ cd doc
$ touch test # create a file
$ ls -l test # check the time stamp of the file
$ file bin test # find our what are bin and test
```

You may notice the hidden files shown in your home directory using the `ls -a` 
command:

``` shell
$ ls -a
.   ..    .bashrc     .profile
```

 So you can use the following command to go up one 
directory:

``` shell
$ cd ..
```

and the following command to run an executable in the current directory:

``` shell
$ ./someExecutableFileInCurrentDirectory
```

You may see something like `.bashrc`. This is a `rc` file. You will meet many 
`rc` files in the future. They are files to save configurations of various 
programs. `.bashrc` is the configuration file for a program called `bash`. The 
full name of the program is [Bourne Again SHell][bash]. It is one of the many 
[Linux Shells](http://www.ibm.com/developerworks/library/l-linux-shells/).

According to [wikipedia][],

> a shell is a user interface for access to an operating system's services. In 
> general, operating system shells use either a command-line interface (CLI) 
> or graphical user interface (GUI), depending on a computer's role and 
> particular operation. It is named a shell because it is a layer around the 
> operating system kernel.

Practically, the word *shell* almost always refers to *CLI* instead of *GUI*. 
In some sense, to learn Linux command-line is to learn how to use a particular 
*shell*. If you don't have any preference at this moment, please try to learn 
[bash][] first because it is probably the most commonly available and used 
one.

What does a *shell* do? First of all, it shows a command prompt after which 
you can type in command. A command prompt sometimes looks like this:


``` shell
UserName@HostName:~ >
```

or this:

``` shell
root@HostName:/ $
```

or something really fancy: 

``` shell
UserName@HostName:~ | 8:30 am | battery: 34% | :-)
```

It all depends on the settings in your *shell*'s `rc` file.

Second, the *shell* analyzes what you have typed in, for example,

``` shell
$ /sbin/ifconfig | grep inet | head -1 | awk '{print $2}'
```

This is a combination of many commands used to print out the IP address of the 
machine nicely. The *shell* needs to understand which words are commands, how 
to execute them one by one and how to pass output of one as input to another.

Third, the *shell* provides a set of key combinations, or [shortcuts][], to 
facilitate the editing of the command line. For example, <kbd>Ctrl+a</kbd> 
moves your cursor to the beginning of the command line, <kbd>Ctrl+e</kbd> moves 
it to the end. Search for *bash shortcuts* on *Google* for a complete list.

The *shell* also provides an *environment* for any command to run. It does so 
by bookkeeping a list of many [environment variables][env]. The following 
command gives you a full list of them in your system:

``` shell
$ env
```

The output is a bit overwhelming. For the moment, you only need to understand 
several of them. You can use the `echo` command to print out the content of an 
environment variable (case sensitive):

``` shell
$ echo $SHELL # The SHELL variable saves the type of shell you are using.
$ echo $HOME # the location of your home directory
$ echo $PATH # list of directories where executables are located
```

You can use the `export` command to declare or change an environment variables 
and make it take effect immediately:

``` shell
$ export AMadeUpEnvVariable="some random text"
$ echo $AMadeUpEnvVariable
$ export SHELL=/bin/zsh # switch to another shell
$ export SHELL=/bin/bash # switch back to use bash
$ export PATH=~/bin:$PATH # add /home/YouUserName/bin/ to $PATH
$ export PS1='\u@\h:\w $' # set prompt to be UserName@HostName:PWD $
```

These settings can be saved in `.bashrc` so that you don't have to type them 
again next time you log in.

Another things that are commonly saved in `.bashrc` are short versions of long 
commands. This is done by creating `alias`es of them:

``` shell
$ alias ls='ls --color -F' # color different types of files in the output of ls
$ alias la='ls -a' # list hidden files using new command la
$ alias l='la -l' # list details of all files using new command l
```

To write those settings to `.bashrc`, you need a [text 
editor](https://en.wikipedia.org/wiki/Text_editor) that can run in a 
*terminal*. If you don't know any text editor, try to use `nano`, which is 
installed in most of the Linux servers and very easy to learn for beginners:

``` shell
$ nano ~/.bashrc # edit .bashrc in your home directory (~/) using nano
```

Type in your settings, type <kbd>Ctrl+o</kbd> to save and <kbd>Ctrl+x</kbd> to 
quit. Use the following command to make your settings take effect immediately:

``` shell
$ source ~/.bashrc # starts to use your new settings in ~/.bashrc
```

It is a bit confusing when we think about the roles that a *termnial* and a 
*shell* play. Simply put, a *terminal* provides a frame, where a *shell* 
exists. The size of the terminal, the font used to display the *shell* prompt, 
commands and output, as well as the mouse clicks are handled by the *terminal*. 
Key strokes will be processed first by the *terminal* and then sent to the 
*shell*.

The middle click of a mouse in most of the Linux terminals would actually do 
the job of *paste*, the same as the <kbd>Ctrl+v</kbd> combination in *Windows*. 
Copy can be done by simply selecting some text in the terminal while holding 
the left button. Double left click on a word will select and copy the whole 
word. Triple click will select the whole line where the mouse is pointing to. 
Right click will most probably bring up a menu provided by the *terminal*.

[bash]:https://www.gnu.org/software/bash
[wikipedia]:https://en.wikipedia.org/wiki/Shell_(computing)
[shortcuts]:http://ss64.com/bash/syntax-keyboard.html
[env]:https://en.wikipedia.org/wiki/Environment_variable
