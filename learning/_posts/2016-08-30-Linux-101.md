---
tags: [Linux, SHELL]
---

![terminal and command line]({{site.ina}}/terminal-and-command-line.png)

### Show things in a directory

A modern Linux PC looks and feels similar to a Windows PC or a Mac. You can use
your mouse to click around, open files, launch programs. What we are going to
cover here is how to use commands instead of a mouse to control your PC. The
first command you may type into a Linux command line is probably `ls`. But
where can you find a Linux command line? In a modern operating system, a
command line is normally provided in a program generally called **terminal** as
shown in the screenshot above. A command is simply a text string you type into
this program. ([MobaXterm][] is such a program for Windows.) You need to press
<kbd>Enter</kbd> to execute a command. The output of the executed command is
shown in the terminal and a new command line is provided below the output
waiting for new input.

[MobaXterm]: {% post_url learning/2020-01-12-easiest-way-to-experience-linux-in-windows %}

The `ls` command lists files and folders in the current directory. This is
equivalent to opening the file explorer in Windows. In the latter, you can tell
whether an item is a file or a directory by its icon. After executing `ls` in a
Linux terminal, the file and folder names will be printed under the command
line. There is no icon for you to tell which is a file or a folder. You can
turn on an option of the `ls` command so that it attaches a letter after the
name of an item to indicate the type of the item:

```sh
$ ls -F
file  folder/  executable*  shortcut@
```

The `-F` string after `ls` is used to turn on this option. I'd like to remember
`F` as **file type** so that I won't forget about it. A dash is needed
IMMEDIATELY before a one-letter option. No space is allowed in between the dash
and the option. A space IS needed between the command and an option though,
otherwise, they'll be regarded by Linux as a single command `ls-F` (which does
not exist) instead of a command `ls` with an option `-F`. A final remark before
we move on is that CASE MATTERS in Linux. You cannot replace `F` with `f` or
`ls` with `Ls`. Actually, there is no `f` option for the `ls` command, and `Ls`
is not a Linux command.

I put a `$` symbol in front of the `ls` command to represent the **command
prompt**, which are simply some text strings normally ended with `$`. They can
be informative or funny. You can change it to your likings once you know more
about Linux. The prompt is not part of the command. You don't have to type it
in your terminal when you follow this instruction. But it is a common practice
to put `$` in front of a command in tutorials to distinguish a command from its
output printed below it.

Now let's take a look at the output of the `ls -F` command. A normal file has
nothing attached to its end. A folder has a slash `/` attached. Note that `\`
is called back slash and is different from `/`. An executable, or a program
that you can run, has a `*` attached to its end. This is necessary because most
Linux programs do not end with `.exe`, you need the `*` to tell whether an item
is an executable or a normal file. A shortcut to an item located somewhere else
ends with an `@`. It is the same as a **Desktop shortcut** in Windows.

A drawback of this method is that someone may regard an attached letter as part
of the name of an item. He may try to do something with `executable*` instead
of `executable` in the example above but only gets an error message saying that
there is no file called `executable*`.

A better way is to show files in different colors according to their types. For
example, normal file names can be shown in white, folders in blue, executables
in red, shortcuts in purple, etc. as shown in the screenshot above. To achieve
this, you need to turn on another option of `ls`, that is, `--color`:

```sh
$ ls --color
```

It is very common for a Linux command to use one dash `-` to indicate a
one-letter option and two dashes `--` to indicate a long option, such as
`color` in this example. What if you want to turn the color display off? I know
it sounds strange, but somebody does prefer black and white. It turns out that
long options sometimes can take an argument. For example,

```sh
$ ls --color=never
```

turns the output back to black and white, where `never` is an argument of the
`color` option.

To learn more about the type of a file, you can use the `file` command:

```sh
$ file some.exe
some.exe: PE32+ executable (console) x86-64 (stripped to external PDB)
```

![long output of ls]({{site.ina}}/long-output-of-ls.png)

It is possible to check the type, the size, the modified date and time of a
file by choosing detailed view in the *Windows File Explorer* as shown in the
screenshot above. The same effect can be achieved by turning on the `-l` (long
list) option of `ls`:

```sh
$ ls -l
-rw-r--r--  1 jintonic physino 12005 Jan  3 16:35 README.md
drwx------+ 1 jintonic physino     0 Sep 26  2018 mail/
lrwxrwxrwx  1 jintonic physino    34 Oct 23  2017 Dropbox -> /cygdrive/c/Users/jintonic/Dropbox/
```

The meaning of each column is briefly explained in the screenshot above.
Detailed explanation of **file permission** can be found in
<https://www.guru99.com/file-permissions.html>

The file size is shown in the unit of byte, which can be a long number for a
large file. You can display it in human readable format using the `h` option,
which can share a single `-` with the `l` option:

```sh
$ ls -lh
-rw-r--r--  1 jintonic physino 1.2G Jan  3 16:35 some.dat
-rw-r--r--  1 jintonic physino 4.3K Jan  3 16:35 file.txt
```

There is an option in the *Windows File Explorer* to show hidden files in a
directory. Similar things can be done in Linux using the `a` (means *all*)
option of `ls`:

```sh
$ ls -a
.  ..  .bashrc  mail  README.md
```

The first three items start with a dot. In Linux, you can add a dot at the
beginning of a file name to turn it into a hidden file. In this example, `mail`
and `README.md` are normal files. `.bashrc` is an hidden file. The single and
double dots have very special meanings. To find out, we need to combine the `a`
and `F` option:

```sh
$ ls -aF
./  ../  .bashrc  mail/  README.md
```

From the `/` letter attached to the ends of them, we know that they are
directories. In fact, One dot means the current directory, two dots means the
parent directory. This brings us to the next section.

### Change directories

The command to change to a different directory is `cd`. To go to the `mail/`
directory, you type (don't forget <kbd>Enter</kbd>)

```sh
$ cd mail
```

To go back to the previous directory, you have two choices. First,

```sh
$ cd ..
```

where `..` means the parent directory as we learned from the previous section.
Second,

```sh
$ cd -
```

where `-` is not part of an option. Instead, it means to *go back to the
previous directory*. The way to remember this is to regard `-` as a minus sign
instead of a dash. Minus means you lose your current position and go back to
the previous one.

You can go into a sub-sub-directory using one command

```sh
$ cd mail/inbox
```

This directory chain can be as long as you want. In this case, `cd ..` brings
you back to the `mail` folder, while `cd -` brings you back to the folder that
contains `mail`.

Up to this point, it looks like that the `ls` command does not take any
argument, while the `cd` command has to take an argument, which is not true.
You can use

```sh
$ ls mail/inbox
```

to list mails in the `mail/inbox` directory. And `cd` without any argument will
take you back to your **home** directory. What is the **home** directory? This
is not a concept familiar to Windows users. Linux uses a quite different
method to organize its files. To learn more, please search "Linux directory
structure" in Google. In short, each Linux user gets a dedicated directory for
her to store her files, which is called the user's home directory. When the
user open a terminal, the start directory is her home directory. The name of
the home directory is the same as the user name. To illustrate how the user
home directories are organized in Linux, let's assume a Linux machine with two
users, jack and rose:

```sh
$ cd /home
$ ls -F
jack/   rose/
```

The home directories for both jack and rose are placed in the same directory
called `/home`. You may ask why this time the `/` is placed in front of a
directory instead of after it? The leading `/` still represents a directory,
but it is a very special one. It is the top directory of the [Linux directory
tree](https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard), or the
*root* directory. It has no parent directory above it. That's why you cannot
put any string in front of it anymore. So

```sh
$ cd /
$ ls -F
bin/  boot/  etc/  home/
```

brings you to the root directory and show you what's in it, where you can find
the `home/` directory that contains all users' home directories.

A directory chain like `mail/inbox` is called a *path*. If a path starts with
`/`, it is called an **absolute path**, since you start at the root directory.
Otherwise, it is called a **relative path**, which starts at the current
directory. So `mail/inbox` is a relative path, it is in the current directory,
instead of in the root directory.

Suppose rose asks you to check a document in her home directory, you can do it
in two ways:

```sh
$ cd /home/rose
```

or

```sh
$ cd ~rose
```

The combination of the tilde symbol `~` and `rose` is a shortcut to `/home/rose`.

A single `~` without any username following it is a shortcut to your own home
directory. So

```sh
$ cd ~
```

is equivalent to

```sh
$ cd
```

A great way to use `~` can be something like this:

```sh
$ cd ~/mail/inbox
```

which brings you from rose's home directly back to your email inbox located in
your home directory.

Suppose that you'd like to get into a directory called `folderWithALongName`.
In Windows, you just need to double click its icon in the *File Explorer*.
While in Linux, the operation involves a lot of typing, until you learn the
<kbd>Tab</kbd> trick, that is, the Linux command line can automatically
complete a file or directory name when you press <kbd>Tab</kbd> after you type
in the first a few letters. So `cd f`<kbd>Tab</kbd> will become `cd
folderWithALongName` automatically if there is no other file starts with `f`.
If there is another file in the same directory called `flights`, nothing
happens when you press <kbd>Tab</kbd> after `f`. Don't give up yet! If you
press <kbd>Tab</kbd> again, the command line will list all files starting with
`f` for you to chose. You can typing a few more letters to break the ambiguity,
for example `fol`, and then press <kbd>Tab</kbd> again to complete the whole
name. So please make it a habit to hit <kbd>Tab</kbd> frequently with your left
pinky when you use `cd`. It will save you a lot of typing.

Another advantage of using <kbd>Tab</kbd> to complete a file or a directory
name is to make sure that you don't type it wrong. For example, if you type `cd
folderw` and two <kbd>Tab</kbd>s after it, nothing will happen, since there is
no file starting with `folderw`. You should then check your spell and realize
that you should have typed `folderW` instead of `folderw`. Such a mistake is
very common in those who just switch from Windows to Linux and have not yet
gotten used to the CASE SENSITIVE nature of Linux. <kbd>Tab</kbd> is your
friend to help you avoid such mistakes.

A file name in Windows can contain *space* in it, for example, `My Document`.
This is not a good idea in Linux though, since

```sh
$ cd My Document
```

will give you an error message `cd: too many arguments`. This is because the
`space` in the command line is used to separate arguments. `My` and `Document`
are separated by the space and are regarded as two different directories in
this case. You cannot go to two different directories at the same time, which
results in the error message.

There are two ways to solve this problem in Linux. One is to quote the file
name:

```sh
$ cd "My Document"
```

The other is to **escape** the *space* with a back slash `\`:

```sh
$ cd My\ Document
```

The `\` in front of the *space* turns the *space* to a normal space from 
a separator between arguments of a command. In general, `\` can be used in
front of special letters in a file name to turn them to normal text characters.
For example, if a directory is named `a "Strange" directory\`, we can turn all
special characters back to normal one by one using `\`:

```sh
$ cd a\ \"Strange\"\ directory\\
```

Yes, a `\` in front of another `\` turns the second `\` to a normal character.

Remember, the <kbd>Tab</kbd> trick still works for names that contain special
characters. So `cd My`<kbd>Tab</kbd> may become `cd My\ Document`
automatically, which is nice.

Even though there is a solution for a file name with *space* in it, you should
try to avoid creating such a name in Linux. Alternatives include `MyDocument`,
`My_Document` or simply `doc`.

One more thing you may need to know before we move to the next section is the
`pwd` command. It is used to *print the working directory*, or where you are
right now, in case you get lost after many `cd` commands:

```sh
$ pwd
/home/jack/mail/trash
```

### Show file content

Equipped with `ls` and `cd`, you can already navigate through a Linux directory
tree. But when you encounter a file named `README.txt`, how can you see its
content? In Windows, it is very easy, you just need to double click the icon,
the file will then be shown in a `notepad`. In Linux, there are programs like
`notepad` as well, they are called [text editors]({% post_url
learning/2016-09-01-terminal-based-text-editors %}). However, what we really
need here is to simply view the file instead of editing it. The simplest way is
to use the `cat` command:

```sh
$ cat README.txt
```

which print the contents of `README.txt` in the terminal. I am always wondering
if there is a Linux command called `dog`. But no, there is none. The `cat`
command works nicely for short files that can be shown within the terminal
window. If a file is longer than what can be shown in a terminal, its contents
will be flashed quickly through the terminal window until the end of it. To
check the disappeared the contents, you can scroll your screen up using your
mouse wheel. If it does not work, try to hold <kbd>Shift</kbd> and then use
<kbd>PageUp</kbd> and <kbd>PageDown</kbd> to scroll up and down.

If you are only interested in part of the contents, for example, only a few
lines at the beginning or end of the file, you can use `head` and `tail`
commands:

```sh
$ head README.txt
$ tail README.txt
```

which shows the first/last 10 lines of `README.txt`, respectively. To specify
how many lines to be shown, you can use the `-n` option, which works for both
`head` and `tail`:

```sh
$ head -n 12 README.txt
$ tail -n 31 README.txt
```

In some system, `-n 12` can be shortened to `-12`.

The `cat`, `head` and `tail` commands are not real viewers. There are two text
viewers that you can use in Linux, `more` and `less`. `less` is better than
`more`, since sometimes *less is more* :)

```sh
$ less README.txt
```

replaces the whole terminal screen with the contents of `README.txt`. To go
back to your command line, you need to type `q` to quit `less`. Inside `less`,
you can use <kbd>PageUp</kbd> and <kbd>PageDown</kbd> to flip pages without
holding <kbd>Shift</kbd>. <kbd>Shift</kbd>+<kbd>PageUp</kbd> and
<kbd>PageDown</kbd> still work, but they flip the terminal pages, instead of
the `less` pages.

The formal name of a `less` page is *alternate screen*. It is NOT the original
terminal *screen* (or *window* as I call it previously). It disappears when you
quit `less` and you are back to the original terminal screen as if `less` has
not printed out anything to the screen. This is a common behavior of many
terminal based programs, such as text editors. You need to realize that the
*alternate screen* is NOT the terminal screen and that they expect completely
different ways of operation. For example, the `less` *alternate screen* does
not understand the `ls` and `cd` commands. To see what `less` does understand,
press <kbd>h</kbd> within `less` to check its help page.

`less` is completely keyboard driven, that is, you use your keyboard instead of
your mouse to control it. The <kbd>j</kbd> key scrolls the page down by one
line, the <kbd>k</kbd> key scrolls the page up by one line. The <kbd>/</kbd>
key allows you to start a search of a string in `README.txt`. The <kbd>n</kbd>
key is used to go to the next occurrence of the search string, <kbd>N</kbd>
goes to the previous occurrence. It takes some practice for you to get used to
these key strokes. But it is worth the effort since many Linux programs share
the same hot keys.

Go back to ancient history, a keyboard at that time did not even have arrow
keys. No wonder ancient programs like `less` can be entirely controlled by keys
on the main typing keypad, which can sometimes more efficient than the
mouse-driven approach.

Now that we learned how to control `less`, I can introduce a very important
Linux command, `man`. It is used to show manuals of other Linux commands in
`less`. For example,

```sh
$ man ls
```

displays a long description of all options that go with the `ls` command. To
learn more about `man`, you can

```sh
$ man man
```

### Combination of commands

The output of a command in the terminal screen has a formal name, `stdout`, or
*standard output stream*. Guess what, a Linux command also has a `stdin` to
accept output stream from another command. Two Linux commands can be chained
with a pipe `|` in between. For example, I can connect the `stdout` of `ls` to
the `stdin` of `less` using `|`:

```sh
$ ls | less
```

This is useful when the output of `ls` is more than that can be displayed in
one terminal screen. You can navigate through the long output of `ls` within
the `less` *alternate screen* using all the `less` hotkeys.

Now guess what the following command chain does:

```sh
$ cat README.txt | head -20 | tail -1
```

It shows the 20-th line of `README.txt` on the terminal screen.

It is also possible to save the output of a command into a file for detailed
check sometime later using

```sh
$ ls > output.txt
```

You can then use `less output.txt` to check the output at any time you want. If
there is already a file named `output.txt` in the current directory, its old
contents will be replaced by the output of `ls`. The following command can be
used to append the output of `ls` to the end of the existing contents:

```sh
$ ls >> output.txt
```

Now you may start to sense the infinite possibility provided by the combination
of simple commands using the `stdout` and `stdin` mechanism. Please check
<https://www.howtogeek.com/435903/what-are-stdin-stdout-and-stderr-on-linux/>
and <https://www.commandlinefu.com/commands/browse/sort-by-votes> to learn
more.

### Create or delete things

```sh
mkdir -p example/advanced/A1
rm -fr example/advanced/A1
mv example/advanced/A1 example/A2
ln -sf example/advanced/A1 A1
touch file
vi README.txt
```

Ref. to [text editors]({% post_url learning/2016-09-01-terminal-based-text-editors %}).

### Check system information

``` shell
$ # things after # is a comment, it won't be executed
$ /sbin/ifconfig # print IP address of the machine you are in
$ uname -a # print operating system information
$ cat /proc/cpuinfo # find out how many CPUs are there in this machine
$ cat /proc/meminfo # find out how big the memory is
$ top # find out who's using the resource, type q to quit
$ df -h # check the disk usage
```

### Configurate the command line

You may see a `.bashrc` file in your home directory. This is a `rc` file. You
will meet many `rc` files in the future. They are files to save configurations
of various programs. `.bashrc` is the configuration file for a program called
`bash`. The full name of the program is [Bourne Again SHell][bash]. It is one
of the many [Linux
Shells](http://www.ibm.com/developerworks/library/l-linux-shells/).

According to [wikipedia][],

> a shell is a user interface for access to an operating system's services. In 
> general, operating system shells use either a command-line interface (CLI) 
> or graphical user interface (GUI), depending on a computer's role and 
> particular operation. It is named a shell because it is a layer around the 
> operating system kernel.

Practically, the word *shell* almost always refers to *CLI* instead of *GUI*. 
In some sense, to learn Linux command-line is to learn how to use a particular 
*shell*. If you don't have any preference at this moment, please try to learn 
[bash][] first because it is probably the most commonly available and used 
one.

What does a *shell* do? First of all, it shows a command prompt after which 
you can type in command. A command prompt sometimes looks like this:


``` shell
UserName@HostName:~ >
```

or this:

``` shell
root@HostName:/ $
```

or something really fancy: 

``` shell
UserName@HostName:~ | 8:30 am | battery: 34% | :-)
```

It all depends on the settings in your *shell*'s `rc` file.

Second, the *shell* analyzes what you have typed in, for example,

``` shell
$ /sbin/ifconfig | grep inet | head -1 | awk '{print $2}'
```

This is a combination of many commands used to print out the IP address of the 
machine nicely. The *shell* needs to understand which words are commands, how 
to execute them one by one and how to pass output of one as input to another.

Third, the *shell* provides a set of key combinations, or [shortcuts][], to 
facilitate the editing of the command line. For example, <kbd>Ctrl+a</kbd> 
moves your cursor to the beginning of the command line, <kbd>Ctrl+e</kbd> moves 
it to the end. Search for *bash shortcuts* on *Google* for a complete list.

The *shell* also provides an *environment* for any command to run. It does so 
by bookkeeping a list of many [environment variables][env]. The following 
command gives you a full list of them in your system:

``` shell
$ env
```

The output is a bit overwhelming. For the moment, you only need to understand 
several of them. You can use the `echo` command to print out the content of an 
environment variable (case sensitive):

``` shell
$ echo $SHELL # The SHELL variable saves the type of shell you are using.
$ echo $HOME # the location of your home directory
$ echo $PATH # list of directories where executables are located
```

You can use the `export` command to declare or change an environment variables 
and make it take effect immediately:

``` shell
$ export AMadeUpEnvVariable="some random text"
$ echo $AMadeUpEnvVariable
$ export SHELL=/bin/zsh # switch to another shell
$ export SHELL=/bin/bash # switch back to use bash
$ export PATH=~/bin:$PATH # add /home/YouUserName/bin/ to $PATH
$ export PS1='\u@\h:\w $' # set prompt to be UserName@HostName:PWD $
```

These settings can be saved in `.bashrc` so that you don't have to type them 
again next time you log in.

Another things that are commonly saved in `.bashrc` are short versions of long 
commands. This is done by creating `alias`es of them:

``` shell
$ alias ls='ls --color -F' # color different types of files in the output of ls
$ alias la='ls -a' # list hidden files using new command la
$ alias l='la -l' # list details of all files using new command l
```

To write those settings to `.bashrc`, you need a [text 
editor](https://en.wikipedia.org/wiki/Text_editor) that can run in a 
*terminal*. If you don't know any text editor, try to use `nano`, which is 
installed in most of the Linux servers and very easy to learn for beginners:

``` shell
$ nano ~/.bashrc # edit .bashrc in your home directory (~/) using nano
```

Type in your settings, type <kbd>Ctrl+o</kbd> to save and <kbd>Ctrl+x</kbd> to 
quit. Use the following command to make your settings take effect immediately:

``` shell
$ source ~/.bashrc # starts to use your new settings in ~/.bashrc
```

It is a bit confusing when we think about the roles that a *termnial* and a 
*shell* play. Simply put, a *terminal* provides a frame, where a *shell* 
exists. The size of the terminal, the font used to display the *shell* prompt, 
commands and output, as well as the mouse clicks are handled by the *terminal*. 
Key strokes will be processed first by the *terminal* and then sent to the 
*shell*.

The middle click of a mouse in most of the Linux terminals would actually do 
the job of *paste*, the same as the <kbd>Ctrl+v</kbd> combination in *Windows*. 
Copy can be done by simply selecting some text in the terminal while holding 
the left button. Double left click on a word will select and copy the whole 
word. Triple click will select the whole line where the mouse is pointing to. 
Right click will most probably bring up a menu provided by the *terminal*.

[bash]:https://www.gnu.org/software/bash
[wikipedia]:https://en.wikipedia.org/wiki/Shell_(computing)
[shortcuts]:http://ss64.com/bash/syntax-keyboard.html
[env]:https://en.wikipedia.org/wiki/Environment_variable
